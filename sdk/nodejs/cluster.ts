// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * Manages [clusters](https://argo-cd.readthedocs.io/en/stable/operator-manual/declarative-setup/#clusters) within ArgoCD.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as argocd from "@three14/pulumi-argocd";
 * import * as aws from "@pulumi/aws";
 * import * as gcp from "@pulumi/gcp";
 * import * as kubernetes from "@pulumi/kubernetes";
 * import * as std from "@pulumi/std";
 *
 * //# Bearer token Authentication
 * const kubernetes = new argocd.Cluster("kubernetes", {
 *     server: "https://1.2.3.4:12345",
 *     config: {
 *         bearerToken: "eyJhbGciOiJSUzI...",
 *         tlsClientConfig: {
 *             caData: std.file({
 *                 input: "path/to/ca.pem",
 *             }).then(invoke => invoke.result),
 *         },
 *     },
 * });
 * //# GCP GKE cluster
 * const cluster = gcp.container.getCluster({
 *     name: "cluster",
 *     location: "europe-west1",
 * });
 * const argocdManager = new kubernetes.core.v1.ServiceAccount("argocd_manager", {metadata: {
 *     name: "argocd-manager",
 *     namespace: "kube-system",
 * }});
 * const argocdManagerClusterRole = new kubernetes.rbac.v1.ClusterRole("argocd_manager", {
 *     metadata: {
 *         name: "argocd-manager-role",
 *     },
 *     rules: [
 *         {
 *             apiGroups: ["*"],
 *             resources: ["*"],
 *             verbs: ["*"],
 *         },
 *         {
 *             nonResourceUrls: ["*"],
 *             verbs: ["*"],
 *         },
 *     ],
 * });
 * const argocdManagerClusterRoleBinding = new kubernetes.rbac.v1.ClusterRoleBinding("argocd_manager", {
 *     metadata: {
 *         name: "argocd-manager-role-binding",
 *     },
 *     roleRef: {
 *         apiGroup: "rbac.authorization.k8s.io",
 *         kind: "ClusterRole",
 *         name: argocdManagerClusterRole.metadata.apply(metadata => metadata.name),
 *     },
 *     subjects: [{
 *         kind: "ServiceAccount",
 *         name: argocdManager.metadata.apply(metadata => metadata.name),
 *         namespace: argocdManager.metadata.apply(metadata => metadata.namespace),
 *     }],
 * });
 * const argocdManagerSecret = new kubernetes.core.v1.Secret("argocd_manager", {metadata: {
 *     name: argocdManager.defaultSecretName,
 *     namespace: argocdManager.metadata.apply(metadata => metadata.namespace),
 * }});
 * const gke = new argocd.Cluster("gke", {
 *     server: cluster.then(cluster => std.join({
 *         separator: "",
 *         input: [
 *             "https://%s",
 *             cluster.endpoint,
 *         ],
 *     })).then(invoke => invoke.result),
 *     name: "gke",
 *     config: {
 *         bearerToken: argocdManagerKubernetesSecret.data.token,
 *         tlsClientConfig: {
 *             caData: cluster.then(cluster => std.base64decode({
 *                 input: cluster.masterAuths?.[0]?.clusterCaCertificate,
 *             })).then(invoke => invoke.result),
 *         },
 *     },
 * });
 * //# AWS EKS cluster
 * const clusterGetCluster = aws.eks.getCluster({
 *     name: "cluster",
 * });
 * const eks = new argocd.Cluster("eks", {
 *     server: clusterGetCluster.then(clusterGetCluster => std.join({
 *         separator: "",
 *         input: [
 *             "https://%s",
 *             clusterGetCluster.endpoint,
 *         ],
 *     })).then(invoke => invoke.result),
 *     name: "eks",
 *     namespaces: [
 *         "default",
 *         "optional",
 *     ],
 *     config: {
 *         awsAuthConfigs: [{
 *             clusterName: "myekscluster",
 *             roleArn: "arn:aws:iam::<123456789012>:role/<role-name>",
 *         }],
 *         tlsClientConfig: {
 *             caData: clusterGetCluster.then(clusterGetCluster => std.base64decode({
 *                 input: clusterGetCluster.certificateAuthorities?.[0]?.data,
 *             })).then(invoke => invoke.result),
 *         },
 *     },
 * });
 * ```
 *
 * ## Import
 *
 * The `pulumi import` command can be used, for example:
 *
 * Cluster credentials can be imported using the server URL.
 *
 * ```sh
 * $ pulumi import argocd:index/cluster:Cluster mycluster https://mycluster.io:443
 * ```
 */
export class Cluster extends pulumi.CustomResource {
    /**
     * Get an existing Cluster resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ClusterState, opts?: pulumi.CustomResourceOptions): Cluster {
        return new Cluster(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'argocd:index/cluster:Cluster';

    /**
     * Returns true if the given object is an instance of Cluster.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Cluster {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Cluster.__pulumiType;
    }

    /**
     * Cluster information for connecting to a cluster.
     */
    declare public readonly config: pulumi.Output<outputs.ClusterConfig>;
    /**
     * Information about cluster cache and state.
     */
    declare public /*out*/ readonly infos: pulumi.Output<outputs.ClusterInfo[]>;
    /**
     * Standard cluster secret's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
     */
    declare public readonly metadatas: pulumi.Output<outputs.ClusterMetadata[] | undefined>;
    /**
     * Name of the cluster. If omitted, will use the server address.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * List of namespaces which are accessible in that cluster. Cluster level resources would be ignored if namespace list is not empty.
     */
    declare public readonly namespaces: pulumi.Output<string[] | undefined>;
    /**
     * Reference between project and cluster that allow you automatically to be added as item inside Destinations project entity. More info: https://argo-cd.readthedocs.io/en/stable/user-guide/projects/#project-scoped-repositories-and-clusters.
     */
    declare public readonly project: pulumi.Output<string | undefined>;
    /**
     * Server is the API server URL of the Kubernetes cluster.
     */
    declare public readonly server: pulumi.Output<string | undefined>;
    /**
     * Optional shard number. Calculated on the fly by the application controller if not specified.
     */
    declare public readonly shard: pulumi.Output<string | undefined>;

    /**
     * Create a Cluster resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ClusterArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ClusterArgs | ClusterState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ClusterState | undefined;
            resourceInputs["config"] = state?.config;
            resourceInputs["infos"] = state?.infos;
            resourceInputs["metadatas"] = state?.metadatas;
            resourceInputs["name"] = state?.name;
            resourceInputs["namespaces"] = state?.namespaces;
            resourceInputs["project"] = state?.project;
            resourceInputs["server"] = state?.server;
            resourceInputs["shard"] = state?.shard;
        } else {
            const args = argsOrState as ClusterArgs | undefined;
            if (args?.config === undefined && !opts.urn) {
                throw new Error("Missing required property 'config'");
            }
            resourceInputs["config"] = args?.config;
            resourceInputs["metadatas"] = args?.metadatas;
            resourceInputs["name"] = args?.name;
            resourceInputs["namespaces"] = args?.namespaces;
            resourceInputs["project"] = args?.project;
            resourceInputs["server"] = args?.server;
            resourceInputs["shard"] = args?.shard;
            resourceInputs["infos"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Cluster.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Cluster resources.
 */
export interface ClusterState {
    /**
     * Cluster information for connecting to a cluster.
     */
    config?: pulumi.Input<inputs.ClusterConfig>;
    /**
     * Information about cluster cache and state.
     */
    infos?: pulumi.Input<pulumi.Input<inputs.ClusterInfo>[]>;
    /**
     * Standard cluster secret's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
     */
    metadatas?: pulumi.Input<pulumi.Input<inputs.ClusterMetadata>[]>;
    /**
     * Name of the cluster. If omitted, will use the server address.
     */
    name?: pulumi.Input<string>;
    /**
     * List of namespaces which are accessible in that cluster. Cluster level resources would be ignored if namespace list is not empty.
     */
    namespaces?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Reference between project and cluster that allow you automatically to be added as item inside Destinations project entity. More info: https://argo-cd.readthedocs.io/en/stable/user-guide/projects/#project-scoped-repositories-and-clusters.
     */
    project?: pulumi.Input<string>;
    /**
     * Server is the API server URL of the Kubernetes cluster.
     */
    server?: pulumi.Input<string>;
    /**
     * Optional shard number. Calculated on the fly by the application controller if not specified.
     */
    shard?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a Cluster resource.
 */
export interface ClusterArgs {
    /**
     * Cluster information for connecting to a cluster.
     */
    config: pulumi.Input<inputs.ClusterConfig>;
    /**
     * Standard cluster secret's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
     */
    metadatas?: pulumi.Input<pulumi.Input<inputs.ClusterMetadata>[]>;
    /**
     * Name of the cluster. If omitted, will use the server address.
     */
    name?: pulumi.Input<string>;
    /**
     * List of namespaces which are accessible in that cluster. Cluster level resources would be ignored if namespace list is not empty.
     */
    namespaces?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Reference between project and cluster that allow you automatically to be added as item inside Destinations project entity. More info: https://argo-cd.readthedocs.io/en/stable/user-guide/projects/#project-scoped-repositories-and-clusters.
     */
    project?: pulumi.Input<string>;
    /**
     * Server is the API server URL of the Kubernetes cluster.
     */
    server?: pulumi.Input<string>;
    /**
     * Optional shard number. Calculated on the fly by the application controller if not specified.
     */
    shard?: pulumi.Input<string>;
}
